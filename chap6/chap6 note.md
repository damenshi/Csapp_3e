# chap6 note

### 1.PPT using blocking to improver temporal locality 需要仔细看加深理解。(看了几遍分块优化时间局部性，对于未命中次数分析还是感觉似懂非懂，留个坑。cache lab讲解中有关于blocking的说明)

### 2.[What Every Programmer Should Know About Memory](https://www.bilibili.com/video/BV1Xy4y1b7SK?p=1&vd_source=7b22fe429e93e65e5f0659d34fcd26d0)

### 3.虽然ROM中有的类型既可以读也可以写，但他们整体上都被称为只读存储器(ROM)

### 4.磁盘容量 1GB = 10^9byte, 1TB = 10^12byte.

### 5.时间局部性：同一数据对象可能会被多次使用。空间局部性：块通常包含多个数据对象。

### 6.高速缓存用中间位做索引：原因是如果高位做索引，那么一些连续内存块可能会被映射到相同的高速缓存块，这就无法提供良好的空间局部性，导致性能下降。

### 7.高速缓冲存储器：直接映射高速缓存、组相联高速缓存、全相联高速缓存

### 8.建议采用写回和写分配的高速缓存模型。

### 练习题

#### 6.1

|组织|r|c|br|bc|max(br, bc)|
|-|:-:|:-:|:-:|:-:|:-:|
|16*1|4|4|2|2|2|
|16*4|4|4|2|2|2|
|128*8|16|8|4|3|4|
|512*4|32|16|5|4|5|
|1024*4|32|32|5|5|5|

#### 6.2
磁盘容量 = 2盘片/磁盘 * 2盘面/盘片 * 10000磁道/盘面 * 400扇区/磁道 * 512byte/扇区
= 8192 000 000 byte
= 8.192GB

#### 6.3
寻道时间 = 8ms
旋转时间 = 1/2 * 60s/15000RPM * 1000ms = 2ms
传送时间 = 60s/15000RPM * 1/500扇区/磁道 * 1000ms = 0.008ms
T = 8 + 2 + 0.008 = 10.008ms

#### 6.4
A.
1MB = 2^20byte
2^20byte / 512byte = 2^11块 = 2048块
读取一个扇区的时间 = 寻道时间 + 旋转时间 + 传送时间
                = 5ms + 1/2 * 60s/10000RPM *1000ms + 60s/10000RPM * 1/1000扇区/磁道 * 1000ms
                = 8.006ms
读该文件所需最优时间 T = 1*8.006ms + 2047*0.006ms = 20.288ms 

B.
随即情况，T = 8.006ms * 2048 = 16396.288ms

#### 6.5
A.T = 128 * 10^15byte / 470 * 10^6 byte/s / (365 * 24 * 60 * 60)
    = 8.6年

B. T = 128 * 10^15byte / 303 * 10^6 byte/s / (365 * 24 * 60 * 60)
    = 13.3年
C. T = 128 * 10^15byte / 20 * 10^9byte/天 / 365
     = 17534年

#### 6.6
2005 - 2015 年旋转磁盘价格下降5/0.03 = 166倍，大概每18个月下降2倍。
2015年 1PB价值300000美元，7次两倍下降后会达到500美元内，所以大概在2025年可以用500美元买到1PB。

#### 6.7

int sumarray3d(int a[N][N][N]){
    int j, j, k;
    for(int k = 0; k < N; k++){
      for(int i = 0; i < N; i++){
        for(int j = 0; j < N; j++){
          sum += a[k][i][j];
        }
      }
    }
    return sum;
}

#### 6.8
b > c > d
clear1以步长为1访问数组，clear2以步长不为1的方式跳到下列相对于结构起始位置：0 12 4 16 8 20. clear3步长更大，跨越整个struct。

#### 6.9 略

#### 6.10
对x， y命中率为3/4.

#### 6.11
A.用高位s做索引,t为标记，每个连续的数组片中有2^t个块。
B.
S = 512 -> 缓存一共512组，地址高9位作为索引。
B = 32 -> 地址低5位作为块偏移。
t = 32 - 9 - 5 = 18位作为标记位，所以数组前2^18个块会映射到缓存的第0组。
数组共 4096 * 4 / 32 = 512个块。
所以该数组所有的块都映射到第0组，该高速缓存每组一行，所以存储在高速缓存中的数组块最多为1块。


#### 6.12 略

#### 6.13
A.
0x0E34 = 01110001 101 00
B.
块偏移CO:0x0, 组索引CI:0x5, 标记CT = 0x71, 命中, 返回0xB。

#### 6.14
A. 
0x0DD5 = 01101110 101 01
B.
块偏移CO:0x01, 组索引CI:0x5, 标记CT = 0x6E, 未命中, 返回—。

#### 6.15
A. 
0x1FE4 = 11111111 001 00
B.
块偏移CO:0x00, 组索引CI:0x1, 标记CT = 0xFF, 未命中, 返回—。

#### 6.16
组3中可以命中的行 标记为0x32, 组索引为0x03
地址范围为 00110010 011 00 ～ 00110010 011 11
0x064C 、0x064D、0x064E、0x064F

#### 6.17
A.
dest数组
||列0|列1|
|:-:|:-:|:-:|
|0行|m|m|
|1行|m|m|

src数组
||列0|列1|
|:-:|:-:|:-:|
|0行|m|m|
|1行|m|h|
src访问顺序 src[0]/[0],src[0]/[1],src[1]/[0],src[1]/[1]
dst访问顺序 dst[0]/[0],dst[1]/[0],dst[0]/[1],dst[1]/[1]

因为高速缓存不够大，对一个数组的引用总是驱逐另一个数组有用的行，当写dst[0]/[0]时会驱逐src[0]/[0].
B.
dest数组
||列0|列1|
|:-:|:-:|:-:|
|0行|m|h|
|1行|m|h|

src数组
||列0|列1|
|:-:|:-:|:-:|
|0行|m|h|
|1行|m|h|
高速缓存足够大，可以放下两个数组。

#### 6.18
A.读总数为2*16*16 = 512次
B.
块大小16byte，一个结构体8byte。循环都是不命中、命中、不命中、命中，以此类推
缓存不命中读总数为256次
C.不命中率为1/2.

#### 6.19
A.读总数为16*16*2 = 512次
B.
grid数组大小为16*16*8 = 2048byte，高速缓存为1024byte，只能缓存数组的一半。
按列读取时，例如读入grid[8]/[0]时，会驱逐grid[0]/[0]时读入的行，改行也包括grid[0]/[1]。
所以每轮内循环，有一半读取未命中。
缓存不命中读总数为256次
C.不命中率为1/2.
D.高速缓存有两倍大，可以缓存整个数组，第1轮内循环有一半读取未命中，第2轮内循环全部命中。第3轮内循环一半未命中，以此类推。不命中率为1/4.

#### 6.20
A.读总数为512次
B.不命中总数为128.
C.不命中率为1/4.
D.依然是1/4，冷不命中无法避免。

#### 6.21
L1吞吐量峰值约为12000MB/s，时钟频率为2100MHz。
读取1byte所需时间为1/(12000 * 10^6) s, 1时钟周期时间为1/(2100 * 10^6)s.
所以L1 d-cache读取1byte所需时钟周期 = 1/(12000 * 10^6) s / 1/(2100 * 10^6)s = 2100/12000 = 0.175
读取8byte所需时钟周期 = 0.175 * 8 = 1.4。
比正常访问L1的延迟4周期快2.5倍，因为4*4循环展开，并行累积可以同时进行多个加载。











